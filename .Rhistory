Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
display(xt,method="raster",all=T)
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
CoverageLab
ImageProcess=function(x,pix=200,offset=0.05,sigma=7){
im=readImage(x) # hold the original image for comparison
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
#combined the images for the summary output
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
#save the image with processed
png(paste0(gsub(".jpg","",x),"_processed.png"))
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
return(data.frame(Image=x,Coverage=Coverage,stringsAsFactors = F)) # return the processed data.
}
ImageProcess("BCS221F5.tif",offset=0.015)
ImageProcess("BCS221F5.tif",offset=0.01)
x
offset
im=readImage(x) # hold the original image for comparison
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
display(im4,method="raster")
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
display(im4,method="raster")
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
Coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
png(paste0(gsub(".tif","",x),"_processed.png"))
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
sigma
sigma=7
im=readImage(x) # hold the original image for comparison
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
Coverage
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
ImageProcess=function(x,pix=200,offset=0.05,sigma=1){
im=readImage(x) # hold the original image for comparison
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
#combined the images for the summary output
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
#save the image with processed
png(paste0(gsub(".tif","",x),"_processed.png"))
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
return(data.frame(Image=x,Coverage=Coverage,stringsAsFactors = F)) # return the processed data.
}
ImageProcess("BCS221F5.tif",offset=0.01)
?png
dim(xt)
dim(im)
dim(im)[1]
png(paste0(gsub(".tif","",x),"_processed.png"),width=dim(im)[1],height = dim(im)[2],unit="px")
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
ImageProcess=function(x,pix=200,offset=0.05,sigma=1){
im=readImage(x) # hold the original image for comparison
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
#combined the images for the summary output
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
#save the image with processed
png(paste0(gsub(".tif","",x),"_processed.png"),width=dim(im)[1],height = dim(im)[2],unit="px")
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
return(data.frame(Image=x,Coverage=Coverage,stringsAsFactors = F)) # return the processed data.
}
ImageProcess("BCS221F5.tif")
ImageProcess("BCS221F5.tif",offset=0.01)
crop=150
is.numeric(crop)
crop=NULL
is.numeric(crop)
dim(crop)
dim(im)
display(im[1:dim(im)[1]-crop])
dim(im)
dim(im)[1]
crop
crop=150
display(im[1:dim(im)[1]-crop,,],method="raster")
display(im[1:dim(im)[1]-crop,],method="raster")
display(im[1:(dim(im)[1]-crop),,],method="raster")
im=readImage(x) # hold the original image for comparison
im2=im
display(im[1:(dim(im)[1]-crop),,],method="raster")
display(im2,method="raster")
display(,im[1:(dim(im)[1]-crop),],method="raster")
display(,im[1:(dim(im)[2]-crop),],method="raster")
display(,im[1:(dim(im)[2]-crop),],method="raster")
dim(im)[2]
crop
dim(im)[2]-crop
display(im[,1:(dim(im)[2]-crop),],method="raster")
ImageProcess=function(x,pix=200,offset=0.05,sigma=1,crop=150){
im=readImage(x) # hold the original image for comparison
#Crop the scale bar off
if(is.numeric(crop)){
im <- im[,1:(dim(im)[2]-crop),]
}
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
#combined the images for the summary output
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
#save the image with processed
png(paste0(gsub(".tif","",x),"_processed.png"),width=dim(im)[1],height = dim(im)[2],unit="px")
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
return(data.frame(Image=x,Coverage=Coverage,stringsAsFactors = F)) # return the processed data.
}
ImageProcess("BCS221F5.tif")
ImageProcess("BCS221F5.tif",offset=0.15)
ImageProcess("BCS221F5.tif",offset=0.015)
source('~/Github/imExtractor/Code/ImageProcess.R')
setwd("TESTFOLDER/")
files <- (Sys.glob("*.jpg"))
Start=Sys.time()
tt <- lapply(files,FUN=ImageProcess)
Sys.time()-Start
mydf <- as.data.frame(do.call(rbind,tt),stringsAsFactors=F)
head(mydif)
head(mydf)
library(ggplot2)
ggplot2(mydf,aes(x="May",y=Coverage))+geom_boxplot()
ggplot(mydf,aes(x="May",y=Coverage))+geom_boxplot()
ggplot(mydf,aes(x="May",y=Coverage))+geom_jitter()+geom_boxplot(alpha=0.7)+theme_bw()
if(length(which(list.files(dir)=="Processed figures"))==0){dir.create(paste0(dir,"Processed figures"))} # if there isn't a 'Figures and Data' folder for output create one
if(length(which(list.files(getwd())=="Processed figures"))==0){dir.create(paste0(getwd(),"Processed figures"))} # if there isn't a 'Figures and Data' folder for output create one
getwd()
if(length(which(list.files(getwd())=="Processed figures"))==0){dir.create(paste0(getwd(),"/Processed figures"))} # if there isn't a 'Figures and Data' folder for output create one
paste0("Processed figures/"gsub(".tif","",x),"_processed.png")
display(xt,all=T,method="raster") #display the images in raster format
dir()
x
paste0("Processed figures/"gsub(".jpg","",x),"_processed.png")
paste0("Processed figures/",gsub(".jpg","",x),"_processed.png")
source('~/Github/imExtractor/Code/ImageProcess.R')
getwd()
dir()
dir()
files <- (Sys.glob("*.jpg"))
files
Start=Sys.time()
tt <- lapply(files,FUN=ImageProcess)
Sys.time()-Start
dir("c:/Users/StanleyR/Documents/Postdoc/DFO/Analysis Help/Renald/mussel reproduction images may 2016/")
getwd()
setwd( "C:/Users/StanleyR/Documents/Github/imExtractor")
tt=imRead("BCS221F5.tif")
tt=readImage3("BCS221F5.tif")
tt=readImage("BCS221F5.tif")
tt=suppressWarnings(readImage("BCS221F5.tif"))
rm(tt)
tt=suppressWarnings(readImage("BCS221F5.tif"))
display(tt,method="raster")
Start=Sys.time()
Sys.time()-Start
rm(tt)
system.time(tt=suppressWarnings(readImage("BCS221F5.tif")))
tt=Sys.time()-Start
tt
gsub("Time difference of","",tt)
Timelog <- Sys.time()-Start
Timelog <- round(as.numeric(gsub("Time difference of","",Timelog)),3)
Timelog
Timelog <- Sys.time()-Start
Timelog
Timelog <- as.character(Sys.time()-Start)
gsub("Time difference of","",Timelog)
Timelog
Timelog <- as.character(Sys.time()-Start)
Timelog
Timelog <- print(Sys.time()-Start)
str(timelog)
str(Timelog)
time(TimeLog)
plot(1:10)
as.numeric(Timelog,units="minutes")
as.numeric(Timelog,units="days")
as.numeric(Timelog,units="min")
as.numeric(Timelog,units="m")
as.numeric(Timelog,units="seconds")
as.numeric(Timelog,units="mins")
Timelog <- Sys.time()-Start
Timelog <- round(as.numeric(Timelog,units="mins"),2)
Timelog
files
getwd()
setwd("C:/Users/StanleyR/Documents/Github/imExtractor/TESTFOLDER/")
files <- (Sys.glob("*.jpg"))
files
ImageMetaData <- lapply(files,FUN=ImageProcess)
output <- as.data.frame(do.call(rbind,ImageMetaData),stringsAsFactors=F)
print(paste("Elapsed time to process",nrow(output),"Images ~",Timelog,"minutes",sep=" "))
files
ImageBatchProcess=function(id){
files <- (Sys.glob("*.jpg")) # identify any
Start=Sys.time() # timing funciton
ImageMetaData <- lapply(files,FUN=ImageProcess)
Timelog <- Sys.time()-Start
Timelog <- round(as.numeric(Timelog,units="mins"),2)
output <- as.data.frame(do.call(rbind,ImageMetaData),stringsAsFactors=F)
print(paste("Elapsed time to process",nrow(output),"Images ~",Timelog,"minutes",sep=" "))
return(output)
}
source('~/Github/imExtractor/Code/ImageProcess.R')
head(output)
imagedata <- as.data.frame(month=rep(month,nrow(output)),
year=rep(year,nrow(output)),
code=rep(code,nrow(output)),
stringsAsFactors=F)
if(is.null(month)){month="Not specified"}
month=NULL
year=NULL
code=NULL
if(is.null(year)){year="Not specified"}
if(is.null(month)){month="Not specified"}
if(is.null(code)){code="Not specified"}
imagedata <- as.data.frame(year=rep(year,nrow(output)),
month=rep(month,nrow(output)),
code=rep(code,nrow(output)),
stringsAsFactors=F)
nrow(output)
rep(year,nrow(output))
rep(month,nrow(output)),
rep(month,nrow(output))
rep(code,nrow(output)
)
imagedata <- as.data.frame(year=rep(year,nrow(output)),
month=rep(month,nrow(output)),
code=rep(code,nrow(output)),stringsAsFactors=F)
imagedata <- data.frame(year=rep(year,nrow(output)),
month=rep(month,nrow(output)),
code=rep(code,nrow(output)),stringsAsFactors=F)
output=cbind(imagedata,output)
output
output <- as.data.frame(do.call(rbind,ImageMetaData),stringsAsFactors=F)
imagedata <- data.frame(Year=rep(year,nrow(output)),
Month=rep(month,nrow(output)),
Code=rep(code,nrow(output)),stringsAsFactors=F)
output=cbind(imagedata,output)
output
ImageBatchProcess=function(id,month=NULL,year=NULL,code=NULL){
files <- (Sys.glob("*.jpg")) # identify any
Start=Sys.time() # timing funciton
ImageMetaData <- lapply(files,FUN=ImageProcess)
Timelog <- Sys.time()-Start
Timelog <- round(as.numeric(Timelog,units="mins"),2)
output <- as.data.frame(do.call(rbind,ImageMetaData),stringsAsFactors=F)
#Add image metadata to the output dataframe
if(is.null(year)){year="Not specified"}
if(is.null(month)){month="Not specified"}
if(is.null(code)){code="Not specified"}
imagedata <- data.frame(Year=rep(year,nrow(output)),
Month=rep(month,nrow(output)),
Code=rep(code,nrow(output)),stringsAsFactors=F)
output=cbind(imagedata,output)
print(paste("Elapsed time to process",nrow(output),"Images ~",Timelog,"minutes",sep=" "))
return(output)
}
ImageBatchProcess=function(dir,month=NULL,year=NULL,code=NULL){
files <- (Sys.glob("*.jpg")) # identify any
Start=Sys.time() # timing funciton
ImageMetaData <- lapply(files,FUN=ImageProcess)
Timelog <- Sys.time()-Start
Timelog <- round(as.numeric(Timelog,units="mins"),2)
output <- as.data.frame(do.call(rbind,ImageMetaData),stringsAsFactors=F)
#Add image metadata to the output dataframe
if(is.null(year)){year="Not specified"}
if(is.null(month)){month="Not specified"}
if(is.null(code)){code="Not specified"}
imagedata <- data.frame(Year=rep(year,nrow(output)),
Month=rep(month,nrow(output)),
Code=rep(code,nrow(output)),stringsAsFactors=F)
output=cbind(imagedata,output)
print(paste("Elapsed time to process",nrow(output),"Images ~",Timelog,"minutes",sep=" "))
return(output)
}
Output=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/",
month="May",year=2016,code="BCD")
Output
source('~/Github/imExtractor/Code/ImageBatchProcess.R')
Output=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/",
month="May",year=2016,code="BCD")
source('~/Github/imExtractor/Code/ImageBatchProcess.R')
Output=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/",
month="May",year=2016,code="BCD")
ImageProcess=function(x,pix=200,offset=0.01,sigma=3,crop=150){
im=suppressWarnings(readImage(x)) # hold the original image for comparison. Since the Tiffs have some missing compression encoding the readImage function will spit out a warning, which are harmless.
#Crop the scale bar off
if(is.numeric(crop)){
im <- im[,1:(dim(im)[2]-crop),]
}
im2=im # make a copy of the original image for processing
colorMode(im2) = Grayscale # convert to grayscale
img=im2
im2=gblur(im2,sigma=sigma)
im3=thresh(im2, pix, pix, offset) # adaptive thresholding based on a pix and offset parametes. Note threshold is applied to each grayscale channel
im4=im3 # create a copy of the thresholded image which can be assigned the color mode for image appending
colorMode(im4) = Color # assign the color mode to match original 'im'
#combine colour channels after the adaptive threshold
Channel1=im3@.Data[,,1] # first grayscale channel
Channel2=im3@.Data[,,2] # second grayscale channel
Channel3=im3@.Data[,,3] # third grayscale channel
stack <- Channel1+Channel2+Channel3 # add channels togegther
#change to the summed stack
im4@.Data[,,1]=stack
im4@.Data[,,2]=stack
im4@.Data[,,3]=stack
#calculate coverage
Coverage <- sum(!stack)/length(stack)*100
CoverageLab <- paste0(round(Coverage,1),"% coverage. ", x)
#combined the images for the summary output
xt=list(im,im4) # create a list of the images for the processing comparision
xt=combine(xt) # append images
#save the images in an output folder where the images are listed from. If not there create it.
if(length(which(list.files(getwd())=="Processed figures"))==0){dir.create(paste0(getwd(),"/Processed figures"))} # if there isn't a 'Figures and Data' folder for output create one
#save the image with processed
png(paste0("Processed figures/",gsub(".jpg","",x),"_processed.png"),width=dim(im)[1],height = dim(im)[2],unit="px")
display(xt,all=T,method="raster") #display the images in raster format
text(x=dim(xt)[1]*0.05,y=dim(xt)[2]*0.05,label = CoverageLab,adj = c(0,1),font=2)
dev.off()
return(data.frame(Image=x,Coverage=Coverage,stringsAsFactors = F)) # return the processed data.
}
Output=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/",
month="May",year=2016,code="BCD")
head(Output)
library(ggplot2)
ggplot(Output,aes(x="test",y=Coverage))+geom_jitter()+geom_boxplot(alpha=0.7)+theme_bw()
range(Output$Coverage)
getwd()
write.table("July_2016_BCD.csv",Output,row.names = FALSE)
write.table("July_2016_BCD.csv",Output,row.names = NULL)
write.table("July_2016_BCD.csv",Output)
write.table(Output,"July_2016_BCD.csv",row.names = F)
Output$Month="July"
write.table(Output,"July_2016_BCD.csv",row.names = F)
Output=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images may 2016/mussel mantle BCD may 2016/",
month="May",year=2016,code="BCD")
getwd()
write.table(Output2,"May_2016_BCD.csv",row.names = F)
Output2=Output
write.table(Output2,"May_2016_BCD.csv",row.names = F)
Output3=ImageBatchProcess(dir="c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images june 2016/mussel mantle BCD june 2016/",
month="June",year=2016,code="BCD")
Output=read.table("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv")
ComboOutput <- rbind(Output2,Output3,Output)
names(output)
names(Output)
names(Output2)
Output=read.csv("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv")
names(Output)
Output=read.csv("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv",header=T)
names(Output)
Output=read.csv("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv",header=T,sep=",")
names(Output)
Output=read.table("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv",header=T,sep=",")
Output=read.table("c:/Users/StanleyR/Documents/Image Analysis/mussel reproduction images july 2016/mussel mantle BCD july 2016/July_2016_BCD.csv",header=T)
names(Output)
ComboData <- rbind(Output2,Output3,Output)
table(ComboData$Month)
ComboData$Month=factor(ComboData$Month,levels=c("May","June","July"))
ggplot(ComboData,aes(x=Month,y=Coverage))+geom_jitter()+geom_boxplot(alpha=0.5)+theme_bw()+labs(x="Month",y="% Coverage")
library(dplyr)
SumData <- ComboData%>%group_by(Month)%>%summarise(MeanCov=mean(Coverage,na.rm=T),
sdCov=sd(Coverage,na.rm=T),
seCov=sd(Coverage,na.rm=T)/sqrt(sum(!is.na(Coverage))))%>%
ungroup()%>%data.frame
ggplot(SumData,aes(x=Month,y=MeanCov))+geom_point()+geom_line+
geom_errorbar(aes(ymin=MeanCov-seCov,ymax=MeanCov+seCov))+
theme_bw()
ggplot(SumData,aes(x=Month,y=MeanCov))+geom_point()+geom_line()+
geom_errorbar(aes(ymin=MeanCov-seCov,ymax=MeanCov+seCov))+
theme_bw()
ggplot(SumData,aes(x=Month,y=MeanCov))+geom_point()+geom_line()+
geom_errorbar(aes(ymin=MeanCov-seCov,ymax=MeanCov+seCov),width=0.2)+
theme_bw()
ggplot(SumData,aes(x=Month,y=MeanCov))+geom_point()+geom_line(stat="identity")+
geom_errorbar(aes(ymin=MeanCov-seCov,ymax=MeanCov+seCov),width=0.2)+
theme_bw()
ggplot(SumData,aes(x=Month,y=MeanCov,group="all"))+geom_point()+geom_line(stat="identity")+
geom_errorbar(aes(ymin=MeanCov-seCov,ymax=MeanCov+seCov),width=0.2)+
theme_bw()
